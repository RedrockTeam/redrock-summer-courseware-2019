# NoSQL

> **NoSQL**，泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。

## Redis

> REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。
>
> Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。

我们为什么使用`Redis`？

###### 

快。



那么为什么快？

- `Redis`是纯内存操作
- 单线程操作，避免了频繁的线程切换
- 采用了非阻塞IO多路复用机制。



**你可以将`Redis`理解为比较厉害的什么东西都能用的`Map`*

`Redis`的`Key`只能为`String`，`Value`可以是:

- 字符串(String)
- 哈希(Hash)
- 列表(List)
- 集合(Set)
- 有序集合(Sorted Set)

我们可以使用`redis-cli`来在命令行操作`Redis`

下面我们来玩一下

### 使用redis-cli操作Redis

先来个普通的字符串的增删改查

```bash
SET hello world
# OK
GET hello
# "world"
EXISTS hello
# (integer) 1
DEL hello
# (interger) 1
```

我们可以对一个键值对进行自增操作

```bash
SET count 1
# OK
INCR count
# (integer) 2
GET count
# "2"
```

或者为一个键值对设置过期时间

```bash
# SETEX key second value
SETEX hello 100 world
```

然后我们再来个`Hash`玩一玩

```bash
HMSET student name "nal" age 20
# OK
HGETALL student
# 1) "name"
# 2) "nal"
# 3) "age"
# 4) "20"
HGET student name
# "nal"
HGETKEYS student
# 1) "name"
# 2) "age"
HDEL student name
# (integer) 1
```

`Hash`是不是非常简单！

`List`、`Set`、`Sorted Set`就不一一示范，可以去`Redis`官方文档查看用法

- List

使用`List`的数据结构，可以做简单的消息队列的功能。我们还可以利用 `lrange `命令，做基于`Redis`的分页功能，性能极佳，用户体验好。

- Set

因为`Set`堆放的是一堆不重复值的集合。所以可以做全局去重的功能。并且我们可以利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。

- Sorted Set

和`Set`比`Sorted Set`多了一个权重参数`Score`，集合中的元素能够按`Score`进行排列。基于这个特点，可以使用`Sorted Set`做排行榜应用。



到现在你已经完全掌握`Redis`最常用的用法了！

好了，现在你可以练习一下：

> 请使用Redis设计一个百万并发服务架构



















好了，我们不皮了，继续。

通过使用`Redis`，我们可以将`Redis`作为缓存，或数据库，或分布式锁。



### 基于Redis的缓存服务

我们可以使用`Redis`作为缓存服务来应对大量高并发下DB压力过大的情况。在高并发情况下，如果所有的请求都统一要到DB做查询操作，大量的查询会使DB的反应变得十分的慢，甚至有可能被一波打穿(x)

![缓存](/home/mashiroc/图片/2019-08-02 13-45-22屏幕截图.png)

我们可以加上缓存来减少服务和DB的压力，但缓存不是银弹，在以下场景下可以考虑使用缓存：

- 短时间内相同数据被重复查询且更新频率不高，这种情况可以考虑使用缓存。应用先查询缓存，如果查询不到数据，则从数据库加载该数据并保存到缓存；
- 高并发热点数据，完全透传到数据库会造成数据库宕机，必须使用缓存；

在以下的场景我们不建议使用缓存：

- 配置型数据在不频繁读的情况下（数据库url等），可以不使用缓存。这类数据建议使用配置中心的方式主动推送；

- 实时性要求较高的数据，不建议使用缓存。比如用户密码，一般只用来做登录校验，不会频繁读取，缓存该数据并不能大幅提升系统性能，还可能导致用户密码修改后不能及时生效从而影响用户体验（缓存更新失败的情况）；

我们的缓存可以是直接加在DB这一层之上，也可以是加在整个服务之上的(即Request发送到服务逻辑之前)。

当我们使用缓存解决了许多问题，并且提高了并发之后，就又带来了新的问题：

- 缓存击穿

  当大量请求去请求一个不存在的`Key`时，大量的请求会同时访问DB，对数据库造成很大压力，如果有人利用此点发起攻击可能会造成严重后果。

- 缓存雪崩

  当大量缓存几乎在同一时间过期，或者服务的缓存服务突然宕机，几乎所有的请求都会访问DB，就会造成缓存雪崩。

- 热点Key

  在我们使用分布式缓存的情况下，可能具有一个或多个`热点Key`，服务会大量请求`热点Key`，分布式的场景下我们需要进行大量`http请求`或`TCP通讯`，就会造成资源浪费，增大服务压力。

- 缓存一致性

  当我们的DB数据更新时，需要更新缓存中的数据，如果在高并发的场景下，这个更新数据的操作就有可能造成`脏读`。

针对以上四点问题，我们针对前三点拿出一些解决方案来：

- 缓存击穿

  我们对于一个不存在的`Key`，可以依旧为其设置一个短时间的缓存，就可以一定程度上解决缓存击穿问题。当然我们也可以使用`布隆过滤器`来解决这个问题。

- 缓存雪崩

  当服务启动之后，会在短时间内设置大量缓存`Key-Value`，如果我们设置了超时时间，那么便会在短时间内大量超时，我们可以为缓存的超时时间设置为一个小范围内的随机值，比如原本`15min`的缓存超时时间，可以设置为13~17分钟内的随机值。

  如果是缓存服务宕机的情况下，最好的解决方案就是赶快把缓存服务跑起来。

- 热点Key

  我们可以针对一些`热点Key`在本机的服务做一个短时间缓存，来一定程度上解决`热点Key`的问题。

  或者我们可以将`热点Key`分成多个`子Key`，分布在缓存集群的不同机器上。

至于最后的缓存一致性，我们单独来讨论：

### 缓存一致性

当我们需要更新数据的时候，我们在更新数据库的同时也需要更新缓存中的数据，我们有以下几种选择：

- 先删缓存，再更新数据库
- 先更新数据库，再删缓存
- 先更新数据库，再更新缓存

我们分别对这三种选择进行讨论：

- 先删除缓存，再更新数据库
  - case 1 ：低并发场景下，先删除缓存，更新数据库后，后续读操作会从数据库读取数据并更新缓存，仅会造成一次缓存未命中；
  - case 2 ： 高并发场景下，写线程T1先删除缓存数据，读线程T2未命中缓存，从数据库读取数据并加载到缓存，然后线程T1更新数据库数据。这时缓存中的值就是原来的老数据，后续读操作都属于脏读。

- 先更新数据库，再删除缓存
  - case 3 ： 先更新数据库，再删除缓存，在删除缓存失败的情况下，也会出现脏数据；
  - case 4 ： 缓存数据失效的瞬间，读线程T1未命中缓存，然后到数据库取数据，取完数据后来了个写线程T2，T2先往数据库写数据，然后删除缓存，接着T1再把读到的老数据加载到缓存，此时也会造成脏读。这个情况出现的概率非常低，需要缓存失效的瞬间有并发的读写操作。而且数据库的写会比读慢很多，并且需要对数据加锁，所以T1必须在T2之前进入数据库进行操作，又要晚于T2更新缓存，所有这些条件都具备的概率非常低。

- 先更新数据库，再更新缓存
  - case 5 ： 假设两个写线程T1、T2并发更新某一数据，T1先获取锁、更新数据库并且释放锁，T2获取锁、更新数据库然后释放锁；接下来T2更新缓存值，T1更新缓存值，这时候缓存中的数据T1为脏数据。

综上，我们不难发现`case 4`是最优的解决方案。

### Redis内存数据库与分布式锁

`Redis`完全可以作为一个数据库来使用，并且它的速度非常的快，我们可以使用`Redis`完成一些高并发服务的数据存储。比如：

- 作为`计数器`，例如：微博点赞数。
- 作为`数据库`，你可以使用Hash来存储对象。
- 在分布式系统下，统一的存储`Session/Cookie`

或其他需要快速读取数据的地方。

我们还可以使用`Redis`在分布式的场景下做为锁来使用：

`Redis`的`String`类型有这样一个API：

```bash
	# 当某个key不存在的时候，设置它的value为某个值。
	SETNX key value
	# 如果成功会返回：
	# (integer) 1
	# 如果失败会返回：
	# (integer) 0
```

所以我们可以使用这个API来实现一个`分布式锁`：

当多个线程同时竞争一个锁时，我们让每个线程循环去调用这个API：

```bash
SETNX lock $timestamp
```

如果执行成功，这个线程便拿到了锁，但是如果在这个线程拿到锁之后来不及释放锁就挂掉了怎么办呢？这里我们就可以为这个锁设置一个超时时间，然后我们拍脑袋调用了下面的命令：

```bash
SETNX lock $timestamp
EXPIRE lock $sometime
```

那么，如果我们设置完锁，还没来得及设置过期时间，线程就挂掉了怎么办呢？

从Redis 2.6.12版本开始，我们可以在SET命令上添加参数：

- `EX seconds` ： 将键的过期时间设置为 `seconds` 秒。 执行 `SET key value EX seconds` 的效果等同于执行 `SETEX key seconds value` 。
- `PX milliseconds` ： 将键的过期时间设置为 `milliseconds` 毫秒。 执行 `SET key value PX milliseconds` 的效果等同于执行 `PSETEX key milliseconds value` 。
- `NX` ： 只在键不存在时， 才对键进行设置操作。 执行 `SET key value NX` 的效果等同于执行 `SETNX key value` 。
- `XX` ： 只在键已经存在时， 才对键进行设置操作。

所以我们可以使用这样的API调用：

```bash
SET lock timestamp EX $sometime NX
```

这样子我们就在一定程度上解决了`死锁`的问题。

## MongoDB

> MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。
>
> 在高负载的情况下，添加更多的节点，可以保证服务器性能。
>
> MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。
>
> MongoDB 将数据存储为一个文档，数据结构由键值(key=>value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。

| SQL术语/概念 | MongoDB术语/概念 | 解释/说明                           |
| :----------- | :--------------- | :---------------------------------- |
| database     | database         | 数据库                              |
| table        | collection       | 数据库表/集合                       |
| row          | document         | 数据记录行/文档                     |
| column       | field            | 数据字段/域                         |
| index        | index            | 索引                                |
| table joins  |                  | 表连接,MongoDB不支持                |
| primary key  | primary key      | 主键,MongoDB自动将_id字段设置为主键 |

主要特点：

- `MongoDB`是一个面向文档存储的数据库，操作起来比较简单和容易。
- 你可以通过本地或者网络创建数据镜像，这使得`MongoDB`有更强的`扩展性`。
- 如果负载的增加(需要更多的存储空间和更强的处理能力)，它可以分布在计算机网络中的其他节点上，这就是所谓的分片。
- `MongoDB`支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。
- `MongoDB`使用`update()`命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。
- MongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。