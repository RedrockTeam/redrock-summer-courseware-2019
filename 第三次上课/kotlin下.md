# kotlin

### kotlin的类型系统

### kotlin中的一个类就可以生成至少两种类型的变量

* 什么意思呢？
* 至少？









##### 关于类型的安全的调用符：

> * ?.    安全调用运算符：如果你声明了一个可空类型的变量，不是空的情况下才会调用成员
>
> * ?:    Elvis运算符：运算符的右值，如果为空的话，就返回左值，不为空的话就返回右值（添加默认值得运算符）
>
> * as?  安全转换运算符:如果类型合适就转过去吧，不合适表达式就返回null，
>
> * ##### !!     非空断言运算符:我很确定他不为空（这个时候如果在调用的时候，变量为空，就会抛出异常）
>
> * let函数:搭配安全调用运算符，在你想把可控的类型，传入一个需要非空参数的函数的时候使用    



##### 基本类型上和java的差异

* 当然基本类型Int，Double，Float，Char，Boolean，也有非空和可空类型的区别。
* 而且在kotlin中基本数据类型没有装箱类型的拆箱类型之分。
* 统一使用，一种类型
* 因为使用基本类型的做法更加高效，所以kotlin会尽可能的使用拆箱类型
* 只在需要的时候才使用装箱类型





##### Any和Any？：根类型

* ```
  Any，同java当中的Object一样是所有类型的父类，但是与java不同的是kotlin中的Any更加广泛，包含书基本的数据类型
  ```





##### Unit类型，kotlin的“void”

* Unit 和 java 的 void的区别

  > Unit是一个完整的类型，而且是有值的，值就是Unit





##### Nothing类型，永不返回的函数

* 永远的不会正常返回的函数：无限循环或者抛出异常





##### 只读集合和可变集合---kotlin集合和java的集合

 * kotlin当中将集合也做了两种区分，分为不可变型和可变型
* 这样做有什么好处呢，答案是很明显的，如果有了这种区分，数据就会更加的安全
* 列如你把一个保存的数据的一个集合传入一个你不清楚的函数，在java当中作为保险起见，通常会先备份一个
* 但是kotlin就不会，一开始就会明确的从类型参数上表示只是作为只读或者读写的模式
* Collection ---》不可变
* MutableCollection ---》可变（MutabColection接口继承了Collection接口）

* java代码中的ArrayList，HashSet等一系列集合，可以完美兼容kotlin，kotlin对他们进行了支持

* 并都继承了可变集合接口，MutableCollection




##### kotlin的数组

* kotlin的数组变成了一个带有参数类型的类

  > 创建数组的方法
  >
  > * arrayOf（）
  > * arrayOfNulls（）
  > * Array，这个类的构造方法，接受一个整形的参数和一个lambda表达式





### 约定

kotlin支持了java中没有运算符重载

```kotlin
operator fun Person.plus(person: Person) = age + person.age
```

但是你并不能重载你自定义的运算符，也不能更改重载运算符的名字

重载运算符需要匹配的只有函数名称和参数数量，对于参数类型是没有要求的



##### 优先级

重载的运算符的优先级，基本上与数字类型的运算的有的优先级是相同的



##### 与java的互通性

由于kotlin的的运算符重载是通过函数来实现的所以和java有很好的互通性，甚至在java中的符合kotlin约定的函数也是可以使用运算符语法来调用



##### 不支持交换性

列如：

```kotlin
    operator fun Person.plus(age: Int):Int = this.age + age
    val mary = Person("Mary", 22, "女")
    val a = mary + 9
    val b = 9 + mary//错误，如需这样做必须再定义一个整形的加号扩展函数
```



##### 各类运算符的重载

* 二元运算符，一个参数，有返回值（“+，-，*，/”）

* 重载复合赋值运算符，一个参数，无返回值("+=,-=,*=,/=")

* 重载一元运算符，无参数（-，+,--,++,!）

  > ++或者--的前置表示还是后置表示只用重载一次，kotlin会根据情况自动调用



##### 等号运算符：“equals”

在kotlin中：

* “==”默认调用了equals这个函数
* “===”才是对应java当中的“==”



##### 集合与区间的约定

* 集合的统统可以通过下标来访问元素

  > 原理也是通过约定，若是在定义了get（）或者set（）函数，就可以通过下标来访问

* 普通的类中如果也定义一个get（）或者set（）约定函数，也是可以通过下标来访问。

列如：

> a[1] = 9
>
> 以上“1”为定义的get（）约定函数的参数“9”为set（）函数的参数
>
> eg：
>
> > ```kotlin
> > operator fun get(a:Int) = a +1 
> > operator fun set(a:Int,b:Int) = a
> > ```



##### "in"的约定和rangeTo的约定



##### 在for循环中使用“iterator”的约定

> 列如
>
> for（x in  list）｛。。。。｝
>
> 当中会自动调用iterator（）来迭代



##### 解构声明和组件函数

* 当你在想要一个函数返回多个数据时，这个约定就提供了很好的支持

```kotlin
data class Bean(val name: String, val age: Int)


val (a, b) = Bean("张三", 99)

/** * 等效于与下面的代码 */

val a = "张三"
val b = 99
```



只需要在类中重载

component1()

component2()

component3()

​        .

​        .

函数，就可以支持这样的表达方式，而kotlin自有的数据类，就自己生成了这一系列方法

其中component1，2，3就随之对应着相应的属性





##### 解构声明用在for循环

for（（key，value） in map）｛

....................................................

｝

这里可以直接调用iterator和component





##### 重用属性访问的逻辑：委托属性

被委托的对象必须重载

* getValue（）
* setValue（）

这样你在定义其他类的属性的时候就可以使用by关键字将这个属性的访问逻辑委托给被委托的对象



##### 懒惰初始化和by lazy

如果你想要一个属性在被使用的时候才被初始化，那么在这个属性的get方法中去写初始化逻辑最好不过，但是如果每个地方你都这样写一遍，未免模板代码太多

* 所以kotlin的库函数就有lazy这个顶层函数，返回一个有getValue（）方法且签名正确的对象
* lazy方法传入一个lambda表达式所以可以直接放在括号外边



 ### 高阶函数：Lambda作为形参和返回值

##### 高阶函数

* 高阶函数就是以另外一个函数作为返回值，或者参数的函数



函数类型：

> (Int,String) -> Unit
>
> 括号里写函数的参数类型
>
> 箭头后面代表返回值类型

* 有了这个函数类型的用法就可以把函数类型当做普通类型来使用（无法作为泛型）

例如：

```kotlin
val a: (String, Int) -> Unit = { a, b -> print("$a $b") }

fun higherOrderFunction(a: (String, Int) -> Unit):(String, Int) -> Unit{
	a("lala", 99)   
	return a
}
```



##### 函数类在java当中

* 函数类类型在java中其实就是函数式接口



##### 内联函数

* lambda会带来额外的运行时开销

  > 原理：如果函数被声明是内联的，函数体会直接被替换的到调用的地方
  >
  > 而lambda正常情况下会被编译成匿名类，内联可以防止这部分开销

* 何时能够被内联

  > * 一般来说，参数如果是直接被调用或者被传递给另外一个inline的函数，那么它是可以被内联的
  >
  > * inline只对带有lambda参数的函数生效，对于普通的函数，jvm已经提供了强大的内联支持，会智能的分析代码执行，将函数进行内联

* 集合的内联操作

  > 集合操作的函数基本都是被声明为内联的，但是在处理大量数据的时候，每调用一次函数都会生成一个中间集合，这些中间集合的消耗是不容小觑的。这时候只需要在处理集合时的调用链上加上asSequence，就可以转换成序列

* 高阶函数的控制流

  > * 在一个函数当中使用高阶函数时，使用return是会直接从高阶函数所依托的函数中返回，这叫做非局部返回
  >
  > * 如果需要在lambda中返回，就需要使用标签
  >
  >   > 例如：
  >   >
  >   > ```kotlin
  >   > list.forEach one@{
  >   >     ............
  >   > }
  >   > ```
  >
  > * 匿名函数
  >
  >   例如：
  >
  >   ```kotlin
  >   list.forEach(fun (string){
  >       ............
  >   })
  >   ```
  >
  >   这种没有名字的函数默认会局部返回，也就是会直接从这个匿名函数中返回

### 泛型

* kotlin的泛型

  > * kotlin泛型与java当中的泛型差别不大基本上雷同。
  > * kotlin如果不指定约束条件，那么就会以Any？为上界，自然就会是可空类型，如果想要想要让类型参数非空，就需要指定非空上界

* 泛型擦除

  > * 与java中相同，kotlin在运行时也会擦除泛型类型。
  >
  >   例如：
  >
  >   ```kotlin
  >   val list = listOf<String>("a", "b", "c")
  >   val list2 = listOf<Int>(1, 2, 3)
  >   ```
  >
  >   在运行时类型都会只是List

* 实化类型参数

  > * 内联函数的类型参数是可以被实化的，因为在编译阶段会把代码内嵌到调用的部分
  >
  >   > 函数要有inline关键字，和利用reified来标记类型
  >   > 例如：
  >   >
  >   > ```kotlin
  >   > inline fun &lt;reified T&gt; test(a: T) {
  >   >     ........................
  >   > }
  >   > ```
  >
  > * 实化类型的使用范围
  >
  >   > * 用在类型检查和类型转换中（is,!is,as,as?）
  >   > * 使用kotlin的反射
  >   > * 获取相应的Class
  >   > * 作为类型参数传递给其他函数

  

* 协变和逆变

  > 协变：保留子类型化参数
  >
  > 逆变：参数反转子类型化参数
  >
  > * 协变只能在out位置使用（返回类型）类中不能有将协变参数类型用在参数的位置
  > * 逆变只能在in位置使用（参数类型）类中不能有将逆变参数类型用在参数的位置
  >
  > 点变形：类似于Java的通配符
  >
  > 星号投影：任一类型类型，但是确定的，与Any?可以包含所有类型的对象有本质差别

### 常用注解

* @JvmOverloads 修饰有默认值的方法，那么在 Kotin 中会暴露多个重载方法
* @JvmField 如果需要在 Java 中将 Kotlin 属性作为字段暴露，那就需要使用 `@JvmField` 注解对其标注。该字段将具有与底层属性相同的可见性。
* @JvmStatic Kotlin 还可以为 **命名对象** 或 **伴生对象** 中定义的函数 **生成静态方法**。如果你将这些函数标注为 @JvmStatic 的话，编译器既会在相应对象的类中生成静态方法，也会在对象自身中生成实例方法。



### 反射

**路还长自己深造吧**







