Android性能优化这部分应该在实践中去理解，我太菜了，没太多经验，网上的教程很多，这次课只能介绍一下常用的工具，介绍一些理论，剩余的部分大佬们自己去在实践中去应用吧



#### 启动速度优化

1. **启动**（此处可以有Demo：比较各个启动方式的差异）

   1. 冷启动
   
      1. 应用发生冷启动时，系统一定会执行下面的三个任务：
   
         - 开始加载并启动应用
         - 应用启动后，显示一个空白的启动窗口（启动闪屏页）
         - 创建应用信息
   
         创建应用信息，系统就需要做的事：
   
         - application的初始化
         - 启动UI线程
         - 创建Activity
         - 导入视图（inflate view）
         - 计算视图大小（onmesure view）
         - 得到视图排版（onlayout view）
         - 绘制视图（ondraw view）
   
         这其中有两个 creation 工作，分别为 Application 和 Activity creation。他们均在 View 绘制展示之前。所以，在应用自定义的 Application 类和 第一个 Activity 类中，onCreate() 方法做的事情越多，冷启动消耗的时间越长。
   
         ![Cold Launch](http://blog.ancard.top/1479177555.png)
   
   2. 温启动
   
      1. 当应用中的 Activities 被销毁，但在内存中常驻时，应用的启动方式就会变为暖启动。相比冷启动，暖启动过程减少了对象初始化、布局加载等工作，启动时间更短。但启动时，系统依然会展示闪屏页，直到第一个 Activity 的内容呈现为止。
   
   3. 热启动
   
      1. 相比暖启动，热启动时应用做的工作更少，启动时间更短。热启动产生的场景很多，常见如：用户使用返回键退出应用，然后马上又重新启动应用。
2. 优化方向
   1. 利用提前展示出来的launcher的theme， 快速展示出来一个界面，
      
      * ```xml
        <style name="SplashTheme" parent="AppTheme">
                <!-- Customize your theme here. -->
                <item name="android:windowFullscreen">true</item>
                <item name="android:windowBackground">@drawable/app_startup</item>
            </style>
        ```
      
      * manifest.xml应用这个主题
      
        ```xml
        <activity android:name=".ui.activity.MainActivity"
                          android:theme="@style/SplashTheme">
                    <intent-filter>
                        <action android:name="android.intent.action.MAIN"/>
                        <category android:name="android.intent.category.LAUNCHER"/>
                    </intent-filter>
                </activity>
        ```
      
      * 在首屏的Activity中setContent之前继续使用原来的主题
      
        ```java
        override fun onCreate(savedInstanceState: Bundle?) {
                setTheme(R.style.AppTheme)
                super.onCreate(savedInstanceState)
                setContentView(R.layout.activity_main)
        	  ….
            }
        ```
      
      我们可以通过主题中的 windowBackground 属性，自定义应用启动时的窗口背景。其实就是两种样式，如图：
      
      ![Launch screens](http://blog.ancard.top/1479196819.png)
      
      新建一个名为 shape_launch.xml 的 drawable 文件，内容如下：
      
      ```
      <?xml version="1.0" encoding="utf-8"?><layer-list 		              xmlns:android="http://schemas.android.com/apk/res/android"    				  android:opacity="opaque">    
          <item android:drawable="@color/colorPrimary"/>    
          <item >        
              <bitmap            
              android:src="@mipmap/ic_launcher"            
              android:gravity="center" />    
              </item>
      </layer-list>
      ```
      
      然后修改 styles.xml 文件中的主题样式：
      
      ```
      <style name="LaunchStyle" parent="AppTheme">	
      <item 
      	name="android:windowBackground">@drawable/shape_launch
      </item>
      </style>
      ```
      
     > 注：该部分若直接使用Style会导致适配以及某些需求部分有问题。为完成适配还是要新增启动页（SplashActivity）来完成相关适配。
      
      最后将这个主题设置给启动的 Activity，设置过程和上面隐藏启动窗口时的设置一样。效果如图：
      
   2. 避免在启动时做密集沉重的初始化（Heavy app initialization）
   
   3. 避免I/O操作，反序列化，网络操作，布局嵌套
   
   参考：[google官网启动优化](https://developer.android.com/topic/performance/vitals/launch-time)

#### 包体积优化

1. APK文件构成

   1. 解压apk：

      ![image.png](https://user-gold-cdn.xitu.io/2018/7/19/164b32fd4bda43f3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

   2. **assets文件夹** 存放一些配置文件、资源文件，assets不会自动生成对应的 ID，而是通过 AssetManager 类的接口获取。

      **res目录** res 是 resource 的缩写，这个目录存放资源文件，会自动生成对应的 ID 并映射到 .R 文件中，访问直接使用资源 ID。

      **META-INF** 保存应用的签名信息，签名信息可以验证 APK 文件的完整性。

      **AndroidManifest.xml** 这个文件用来描述 Android 应用的配置信息，一些组件的注册信息、可使用权限等。

      **classes.dex** Dalvik 字节码程序，让 Dalvik 虚拟机可执行，一般情况下，Android 应用在打包时通过 Android SDK 中的 dx 工具将 Java 字节码转换为 Dalvik 字节码。

      **resources.arsc** 记录着资源文件和资源 ID 之间的映射关系，用来根据资源 ID 寻找资源。

2. 需要从代码和资源两个方面去减少响应的大小。

   1. 使用lint工具：可以用来检查 没有使用过的资源(试一下自己的项目)

   2. 开启资源压缩

      ```gradle
      android {
          ...
          buildTypes {
              release {
                  shrinkResources true
                  minifyEnabled true
                  proguardFiles getDefaultProguardFile('proguard-android.txt'),
                          'proguard-rules.pro'
              }
          }
      
      ```

3. 可绘制对象，某些图像不需要静态图像资源; 框架可以在运行时动态绘制图像。Drawable对象（`<shape>`以XML格式）可以占用APK中的少量空间。此外，XML Drawable对象产生符合材料设计准则的单色图像

4. 使用WebP文件格式(此处应该动手)

5. 代码混淆

#### 耗电优化

1. 需要进行网络请求时，我们需先判断网络当前的状态。
2. 在多网络请求的情况下，最好进行批量处理，尽量避免频繁的间隔网络请求。
3. 在同时有wifi和移动数据的情况下，我们应该直接屏幕移动数据的网络请求，只有当wifi断开时在调用，因为，wifi请求的耗电量远比移动数据的耗电量低的低。
4. 后台任务要尽可能少的唤醒CPU。（比方说，锁屏时，QQ的消息提示行就是唤醒了CPU。但是它的提示只有在你打开锁屏或者进行充电时才会进行提示。）

#### 网络优化

##### 1. 图片优化

1. 对图片质量进行压缩

   ```kotlin
     public static Bitmap compressImage(Bitmap bitmap){  
               ByteArrayOutputStream baos = new ByteArrayOutputStream();  
               //质量压缩方法，这里100表示不压缩，把压缩后的数据存放到baos中  
               bitmap.compress(Bitmap.CompressFormat.JPEG, 100, baos);  
         		//这个参数的意思是保留原图像的100%品质
               int options = 100;  
               //循环判断如果压缩后图片是否大于50kb,大于继续压缩  
               while ( baos.toByteArray().length / 1024>50) {  
                   //清空baos  
                   baos.reset();  
                   bitmap.compress(Bitmap.CompressFormat.JPEG, options, baos);  
                   options -= 10;//每次都减少10  
               }  
               //把压缩后的数据baos存放到ByteArrayInputStream中  
               ByteArrayInputStream isBm = new ByteArrayInputStream(baos.toByteArray());  
               //把ByteArrayInputStream数据生成图片  
               Bitmap newBitmap = BitmapFactory.decodeStream(isBm, null, null);  
               return newBitmap;  
           }  
   
   ```

2. 对图片尺寸进行压缩

   * 获取加载图片的属性
         Android中的BitmapFactory类提供了一些解码方法，decodeByteArray()、decodeFile()、decodeResource()等等，根据不通的图片源选择不同的解码方法加载图片创建出Bitmap。这些方法中都会传入一个BitmapFactory.Options实例化对象，通过这个对象，可以更改一些加载图片的设置。由于这些解码方法用于解码加载图片，会占用内存构建Bitmap，因此很容易导致OOM的异常。 
     如果将options.inJustDecodeBounds设置为true，在解码过程中就不会申请内存去创建Bitmap，返回的是一个空的Bitmap，但是可以获取图片的一些属性，例如图片宽高，图片类型等等。

     ```java
     BitmapFactory.Options options = new BitmapFactory.Options();
     options.inJustDecodeBounds = true;      // 设置为true，不将图片解码到内存中
     BitmapFactory.decodeResource(getResources(), R.id.myimage, options);
     int imageHeight = options.outHeight;    // 图片高度
     int imageWidth = options.outWidth;      // 图片宽度
     String imageType = options.outMimeType; // 图片类型
     ```

     一般来说，为了避免OOM的异常，在加载图片到内存之前，会先检查图片的尺寸，除非你能确保图片源不会导致OOM。

   * 缩小图片的长宽来压缩图片
     我们知道图片的大小之后，就可以决定是否将完整的图片加载到内存或者加载压缩版的图片到内存。可以基于以下几点做出决定：

     估计完整图片加载到内存中所使用内存
     可分配给加载图片的内存
     用于显示图片的控件的大小
     当前设备的屏幕大小和密度
     例如，如果显示图片的控件大小为128x96像素，就没有必要将一个1024x768像素的图片加载到内存中。

        >设置options.inSampleSize的数值，来控制压缩图片程度。例如，将options.inSampleSize设置为4，将一个2048x1536像素的图片解码加载到内存后产生的Bitmap大约为512x384像素，如果使用的位图配置是ARGB_8888，那么仅仅需要0.75M就加载了缩小版的图片到内存，而加载完整的图片需要12M。
        >
        >   也就是说，如果我们设置inSampleSize == 2，解码出来的位图的宽高是原图的1/2，图片所占用内存缩小了1/4（1/2 x 1/2）。如果inSampleSize设置的值小于等1，都会当做inSampleSize == 1来解码加载图片。

     于是我们可以在加载图片的时候，根据控件的大小（显示到屏幕上的大小）来计算出加压缩版图片的inSampleSize值。

     ```java
     /**
      * 计算inSampleSize值
      *
      * @param options
      *          用于获取原图的长宽
      * @param reqWidth
      *          要求压缩后的图片宽度
      * @param reqHeight
      *          要求压缩后的图片长度
      * @return
      *          返回计算后的inSampleSize值
      */
     public static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) {
         // 原图片的宽高
         final int height = options.outHeight;
         final int width = options.outWidth;
         int inSampleSize = 1;
     
         if (height > reqHeight || width > reqWidth) {
     
             final int halfHeight = height / 2;
             final int halfWidth = width / 2;
                     // 计算inSampleSize值
             while ((halfHeight / inSampleSize) >= reqHeight
                     && (halfWidth / inSampleSize) >= reqWidth) {
                 inSampleSize *= 2;
             }
         }
     
         return inSampleSize;
     }
     ```

        有人可能会疑问为什么每次inSampleSize都是乘以2，指数增长。这是因为在加载图片过程中，解析器使用的inSampleSize都是2的指数倍，如果inSampleSize是其他值，则找一个离这个值最近的2的指数值。

     上面已经获取了inSampleSize，然后就可以根据这个值来加载压缩版的图片了。

     ```java
     public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId,
             int reqWidth, int reqHeight) {
         // 先将inJustDecodeBounds设置为true来获取图片的长宽属性
         final BitmapFactory.Options options = new BitmapFactory.Options();
         options.inJustDecodeBounds = true;
         BitmapFactory.decodeResource(res, resId, options);
     // 计算inSampleSize
     options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);
     
     // 加载压缩版图片
     options.inJustDecodeBounds = false;
     // 根据具体情况选择具体的解码方法
     return BitmapFactory.decodeResource(res, resId, options);
     }
     ```
     
     获取到了压缩版的Bitmap之后就可以直接设置到屏幕的控件上了。
     
     ```java
      mImageView.setImageBitmap(
          decodeSampledBitmapFromResource(getResources(), R.id.myimage, 100, 100));
     ```
   
3. 使用libjpeg.so库进行压缩

4. 使用WebP格式：采用WebP格式可大幅节省流量，相对于JPG格式的图片，流量能节省将近 25% 到 35 %；相对于 PNG 格式的图片，流量可以节省将近80%。最重要的是使用WebP之后图片质量也没有改变（AndroidStudio支持自动的jpg,png转webp)

   > WebP的优势在于它具有更优的图像数据压缩算法，在拥有肉眼无法识别差异的图像质量前提下，带来更小的图片体积，同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都非常优秀、稳定和统一。

##### 2.网络请求处理

1. 我们可以对服务端返回数据进行缓存，设定有效时间，有效时间之内不走网络请求，减少流量消耗。

   1. 配置okhttp中的Cache

      ```java
      OkHttpClient okHttpClient = new OkHttpClient();
      File cacheFile = new File(context.getCacheDir(), "[缓存目录]");
      Cache cache = new Cache(cacheFile, 1024 * 1024 * 100); //100Mb
      okHttpClient.setCache(cache);
      ```

   2. 配置请求头

      ```java
      @Headers("Cache-Control: public, max-age=3600)
      @GET("merchants/{shopId}/icon")
      Observable<ShopIconEntity> getShopIcon(@Path("shopId") long shopId);
      ```
   
   3. 云端配合设置响应头或者自己写拦截器修改响应头response中cache-control

 

2. 在某些情况，尽量少使用GPS定位，如果条件允许，尽可能使用网络定位。

3. 下载、上传，尽可能使用断点

4. 刷新数据时，尽可能使用局部刷新，而不是全局刷新

   比如说RecyclerView的Adapter使用  `notifyItemRangeChanged()`或者 `notifyItemChanged()` 而不是 `notifiyDataSetChanged()`.

#### 线程优化

1. 采用线程池，避免在程序中存在大量的Thread.线程池可以重用内部的线程，从而避免了现场创建和摧毁带来的性能开销

#### 微优化（主要是Java)

1. 编写高效代码有两个基本规则：
   
   - 不需要做的工作就不要做。
   - 如果可以避免，就不要分配内存
   
   **避免创建不必要的对象**
   
   创建对象绝不是没有成本的。带有针对临时对象的线程级分配池的分代垃圾回收器可以降低分配成本，但分配内存的成本总是要高于不分配内存。
   
   随着在应用中分配越来越多的对象，会强制进行定期垃圾回收，导致用户体验出现小“问题”。
   
   因此，应该避免创建不需要的对象实例。以下是示例：
   
   - 如果有一个返回字符串的方法，并且知道其结果无论如何都会附加到某个 `StringBuffer`，则更改签名和实现，以便函数直接进行附加，而非创建短期的临时对象。
   - 从一组输入数据中提取字符串时，请尝试返回原始数据的子字符串，而非创建副本。您会创建一个新的 `String` 对象，但它会与这些数据共享 `char[]`。（需要权衡的是，如果您只使用原始输入中的一小部分，那么如果您采用这种方法，便会将原始输入全部保留在内存中。）
   
   **将多维数组切片为并行的单维数组：**
   
   - `int` 数组的效果比 `Integer` 对象数组好很多，这一点也可以延伸到以下事实：两个并行的 int 数组同样比一个 `(int,int)` 对象数组高效**很多**。任何基本类型的组合都是如此。
   - 如果需要实现存储 `(Foo,Bar)` 对象元组的容器，两个并行 `Foo[]` 和 `Bar[]` 数组的效果通常比单个自定义 `(Foo,Bar)` 对象的数组好很多。
   
   一般来说，要尽量避免创建短期临时对象。创建的对象数量越少，就意味着垃圾回收频率越低，而这会直接优化用户体验。
   
   
   
   **静态优先于虚拟**
   
   如果您不需要访问某个对象的字段，则将相应方法设为静态。调用速度会提高大约 15%-20%。这也是一种很好的做法，因为根据方法签名就能确定调用此方法不会更改对象的状态。
   
   对常量使用静态 final
   
   下面是位于类顶部的声明：
   
   ```java
       static int intVal = 42;    static String strVal = "Hello, world!";    
   ```
   
   
   
   编译器会生成一个名为 `<clinit>` 的类初始化器方法，当第一次使用该类时，系统会执行此方法。此方法会将值 42 存储到 `intVal`，并从类文件字符串常量表中提取 `strVal` 的引用。以后引用这些值时，可以通过查询字段访问它们。
   
   什么是clinit
   
   * init是对象构造器方法，也就是说在程序执行 new 一个对象调用该对象类的 constructor 方法时才会执行init方法，而clinit是类构造器方法，也就是在jvm进行类**加载—–验证—-解析—–初始化**，中的初始化阶段jvm会调用clinit方法。
   
   ```java
   class X {
   
      static Log log = LogFactory.getLog(); // <clinit>
   
      private int x = 1;   // <init>
   
      X(){
         // <init>
      }
   
      static {
         // <clinit>
      }
   
   }
   ```
   
   
   
   我们可以使用“final”关键字加以改进：
   
   ```java
       static final int intVal = 42;    static final String strVal = "Hello, world!";    
   ```
   
   
   
   此类不再需要 `<clinit>` 方法，因为常量会进入 dex 文件中的静态字段初始化器。引用 `intVal` 的代码将直接使用整数值 42，并且对 `strVal` 的访问将使用成本相对较低的“字符串常量”指令，而非字段查询。
   
   **注意**：此优化仅适用于基本类型和 `String` 常量，不适用于任意引用类型。尽管如此，最好还是尽可能声明常量 `static final`。
   
   使用增强型 for 循环语法
   
   对于实现 `Iterable` 接口的集合以及数组，可以使用增强型 `for` 循环（有时也称为“for-each”循环）。对于集合，系统会分配迭代器以对 `hasNext()` 和 `next()` 进行接口调用。对于 `ArrayList`，手写计数循环的速度快约 3 倍（有或没有 JIT），但对于其他集合，增强型 for 循环语法与使用显式迭代器完全等效。
   
   遍历数组有以下几种替代方案：
   
   ```java
       static class Foo {
           int splat;
       }
   
       Foo[] array = ...
   
       public void zero() {
           int sum = 0;
           for (int i = 0; i < array.length; ++i) {
               sum += array[i].splat;
           }
       }
   
       public void one() {
           int sum = 0;
           Foo[] localArray = array;
           int len = localArray.length;
   
           for (int i = 0; i < len; ++i) {
               sum += localArray[i].splat;
           }
       }
   
       public void two() {
           int sum = 0;
           for (Foo a : array) {
               sum += a.splat;
           }
       }  
   ```
   
   
   
   `zero()` 速度最慢，因为 JIT 还无法消除每次循环迭代都要获取数组长度这项成本。
   
   `one()` 速度更快。它会将所有内容都提取到局部变量中，避免查询。只有数组长度方面具有性能优势。
   
   对于没有 JIT 的设备，`two()` 速度最快；对于有 JIT 的设备，two() 与 **one()** 没有速度区别。two() 使用了在 1.5 版 Java 编程语言中引入的增强型 for 循环语法。
   
   > **JIT**编译器，英文写作**Just-In-Time** Compiler，中文意思是即时编译器。 **JIT**是一种提高程序运行效率的方法。 通常，程序有两种运行方式：静态编译与动态解释。 静态编译的程序在执行前全部被翻译为机器码，而动态解释执行的则是一句一句边运行边翻译。
   
   因此，应该默认使用增强型 `for` 循环，但对于对性能至关重要的 `ArrayList` 迭代，您可以考虑使用手写计数循环。
   
   **提示**：另请参阅 Josh Bloch 的《Effective Java》第 46 条。
   
   对于私有内部类，考虑使用包访问权限，而非私有访问权限
   
   请查看以下类定义：
   
   ```java
   public class Foo {
           private class Inner {
               void stuff() {
                   Foo.this.doStuff(Foo.this.mValue);
               }
           }
   
           private int mValue;
   
           public void run() {
               Inner in = new Inner();
               mValue = 27;
               in.stuff();
           }
   
           private void doStuff(int value) {
               System.out.println("Value is " + value);
           }
       }
   ```
   
   
   
   对于上述代码，需要注意的是，我们定义了一个私有内部类 (`Foo$Inner`)，它会直接访问外部类中的私有方法和私有实例字段。这是合乎规则的，并且代码会按预期输出“Value is 27”。
   
   问题在于，虚拟机认为从 `Foo$Inner` 直接访问 `Foo` 的私有成员不符合规则，因为 `Foo` 和 `Foo$Inner` 属于不同的类，虽然 Java 语言允许内部类访问外部类的私有成员。为了消除这种差异，编译器会生成一些合成方法：
   
   ```java
      /*package*/ static int Foo.access$100(Foo foo) {
           return foo.mValue;
       }
       /*package*/ static void Foo.access$200(Foo foo, int value) {
           foo.doStuff(value);
       }
   ```
   
   
   
   每当需要访问外部类中的 `mValue` 字段或调用外部类中的 `doStuff()` 方法时，内部类代码就会调用这些静态方法。这意味着以上代码实际上可以归结为一种情况，那就是您通过访问器方法访问成员字段。之前我们讨论了访问器的速度比直接访问字段要慢，因此这是一个特定习惯用语会对性能产生“不可见”影响的示例。
   
   如果您在性能关键位置 (hotspot) 使用这样的代码，则可以将内部类访问的字段和方法声明为拥有包访问权限（而非私有访问权限），从而避免产生相关开销。遗憾的是，这意味着同一软件包中的其他类可以直接访问这些字段，因此不应在公共 API 中使用此方法。
   
   避免使用浮点数
   
   一般来讲，在 Android 设备上，浮点数要比整数慢约 2 倍。
   
   在速度方面，`float` 和 `double` 在更现代的硬件上没有区别。在空间方面，`double` 所占空间大 2 倍。对于台式机，假定空间不是问题，您应该优先使用 `double`，而非 `float`。
   
   此外，即使对于整数，某些处理器拥有硬件乘法器，却缺少硬件除法器。在这种情况下，整数的除法和取模运算会在软件中执行；如果您要设计哈希表或要进行大量数学运算，则需要考虑这一点。

参考：[google官网](https://developer.android.com/training/articles/perf-tips)

#### 性能分析工具

1. Systrace分析页面性能
2. TraceView 和dmtracedump分析性能
3. CPU profiler

参考：[掘金](https://juejin.im/post/5b50b017f265da0f7b2f649c)

参考：[掘金](https://juejin.im/post/5a0d30e151882546d71ee49e)

参考：[Android应用性能完全分析](https://blog.csdn.net/yanbober/article/details/48394201#t33)
