# **Android性能优化**

## 一、必要性？

Android作为移动设备，内存和CPU受到一定限制，无法达到PC级水准，使用不当会产生各种问题。以下是两个典型问题

**OOM**（过度使用内存）

**ANR**（过度使用CPU）

## 二、布局优化

### 1.选择合适的ViewGroup

- 关于合适的定义：在不影响需求的实现前提下，选择**使用性能较低**的，**LinearLayout**            和 **FrameLayout**，RelativeLayout相对复杂

- LinearLayout或FrameLayout无法实现需求的条件下，可以考虑**RelativeLayout**，而不是嵌套更多的布局

### 2.使用标签< include>复用布局

- 仅支持**android:layout_XXX** 这类属性，**android:id**是例外

- 若被包含的布局文件的根布局也指定了**id**属性，**以< include>指定的id为准**

- android:layout_width** 和 **android:layout_height**需同时存在其他android：layout_XX属性才能生效

下面是一个**示例**

**activity_main.xml**     /      **test_layout.xml**

```xml
<LinearLayout >
    ...
    <include
        android:id="@+id/main_include_layout"
        android:layout_width="50dp"
        android:layout_height="100dp"
        android:layout_marginTop="30dp"
    layout="@layout/test_layout" />
</LinearLayout>
```

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="60dp"
    >
    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="test1"
        android:textSize="30sp"/>
    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="test2"
        android:textSize="30sp"/>
</LinearLayout>
```

### **3.使用< merge>（合并）标签**，减少视图结点

- **什么时候使用？**

在上面的例子中，LinearLayout中使用了< include>,被嵌套的布局也是Linearlayout，   可以用merge代替被嵌套的布局

```xml
<merge xmlns:android="http://schemas.android.com/apk/res/android">
    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="test1"
        android:textSize="30sp"/>
    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="test2"
        android:textSize="30sp"/>
</merge>
```

在这里就减少了一个LinearLayout的视图结点

- merge标签用在**被嵌套**的布局且只能作为XML布局的**根标签**使用

- 因为merge不是View，所以对merge标签设置的所有属性都是**无效**的。

- 因为merge标签并不是View，所以在通过LayoutInflate.inflate方法渲染的时候， 第二个参数**必须指定一个父容器**，且**第三个参数必须为true**，也就是必须为merge下的视图指定一个父亲节点。

- 如果Activity的布局文件根节点是**FrameLayout**，可以替换为merge标签，这样，执行setContentView之后，会减少一层FrameLayout节点

### **4.查看布局结构**

工具：**hierarchyviewer** 或  **Layout inspector**

hierarchyviewer在最新的AS里已经被淘汰了，所以在As里无法使用，以下为使用方法

- 找到存放SDk的文件夹

- 打开monitor.bat

  ![](http://ww1.sinaimg.cn/mw690/006nwaiFly1g5rkjpync7j30gc07egmp.jpg)

![](http://ww1.sinaimg.cn/mw690/006nwaiFly1g5rkknrjecj30ib0f2jst.jpg)

**Layout inspector**

![](http://ww1.sinaimg.cn/mw690/006nwaiFly1g5rkl8bodqj305s08a3yt.jpg)

****

### 5.使用ViewStub延迟加载

- 继承View，**宽高为0**，**不参与任何布局和绘制过程**

- 主要用途：参考View.GONE

 示例：

```xml
<ViewStub
    android:id="@+id/view_stub"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout="@layout/test_layout"
    android:inflatedId="@layout/test_layout根元素的id"/>
```

- 显示viewStub中的布局有两种方式

```java
viewStub.setVisibility(View.VISIBLE);
```

或者

```java
viewStub.inflate();//只能调用一次，多次调用会抛异常，ViewParent must not null
```

注意：一旦viewStub中的布局加载出来后，viewStub不再是整个布局结构中的一部分了，可以用上面的工具查看到布局结构中已经没有viewStub了，它的ViewParent为null。因此**inflate()方法只能调用一次**

- 与**View.GONE**的区别？

   设置为GONE的View不会占用布局空间，但是会进行类的初始化；如ImageView 将src设置为一个BitmapDrawable，那么该图片将会加载到内中

   ViewStub只有在代码中进行inflate之后才会加载进来，不会占用内存

- **不支持< merge>标签**

## 三、绘制优化

### 1.降低ondraw复杂度

- 避免创建局部对象，ondraw频繁调用的时候会在一瞬间产生大量对象，占用过多内存，频繁GC，降低执行效率

- 避免**大量** & **耗时**操作。60fps最佳，每帧的绘制时间不超过1000ms/60 = 16ms

### 2.避免过度绘制

- 过度绘制的表现形式，会导致屏幕显示的色块不同（**开启GPU过度绘制调试**）

   尽可能控制在两次（绿色）以下

   ![](https://upload-images.jianshu.io/upload_images/944365-fb4a2fa466fc67df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/782/format/webp)

-   **2. 解决方案**

  移除默认背景

  ```xml
   <style name="xxx"parent="xxx">
          <item name="android:windowBackground">@null</item>
   </style>
  ```

  如果不需要给根布局添加背景就不要移除了，一层背景都没有会出问题

​      **移除空间中不必要的背景**，例如

​     .1) RecycleView和item，若item无背景要求就不要添加背 景，可减少一次过度绘制

​     .2)多层ViewGroup嵌套时，将被完全覆盖的ViewGroup的背景取消

​     .3)viewpager+fragment(activity根布局背景，viewpager本身的背景)

​    canvas.clipRect()裁剪画布

​    只有在这个裁剪矩形区域内的才会被绘制，区域之外的都不绘制，一个典型 的例子

​    DrawerLayout

![img](https://jaeger.itscoder.com/img/postimg/cp_clip_rect.jpg)

![img](https://jaeger.itscoder.com/img/postimg/cp_drawerlayout.png)

   优化过度绘制： <https://jaeger.itscoder.com/android/2016/09/29/android-performance-overdraw.html>

## 四、内存泄漏&内存溢出

> **内存泄露**：**程序在向系统申请分配内存空间后(new)，在使用完毕后未释放。**结果导致一直占据该内存单元，我们和程序都无法再使用该内存单元，直到程序结束，这是内存泄露。

>**内存溢出**：**程序向系统申请的内存空间超出了系统能给的。**比如内存只能分配一个int类型，我却要塞给他一个long类型，系统就出现oom。



### 1.Java的内存模型

**栈(stack)**：是简单的数据结构，但在计算机中使用广泛。栈最显著的特征是：**LIFO(Last In, First Out, 后进先出)**，只存放基本类型变量和对象的引用,**每个线程都有一个**

**堆(heap)**：堆内存用于存放由**new创建的对象和数组**。在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。JVM只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身。

**方法区(method)**：又叫静态区，跟堆一样，**被所有的线程共享**。方法区包含所有的class和static变量。

以方法调用来阐释堆和栈的联系，在一个正在运行的线程中，每一次调用方法，栈中会压入一个单元（**frame**）,保存参数，局部变量和返回地址，当方法结束后，对应的frame出栈，参数，局部变量占的**内存随之释放**。在堆中，对象占据的内存不会随着方法结束被释放，时间久了，堆中对象占的内存会越来越多，直到OOM，引入垃圾回收机制

### 2.垃圾回收机制（GC）

针对上述问题，java引入GC，即一个后台专门垃圾回收的线程。

#### .1)引用类型

强引用，软引用，弱引用，虚引用

#### .2)判定一个对象是否可回收

- 引用计数法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；**计数器为0可回收**

  **缺点**：对于相互引用的对象无法进行回收

  ```java
  public class ReferenceCountingGC {
      public Object instance = null;
  
      public static void testGC() {
  
          ReferenceCountingGC objA = new ReferenceCountingGC();
          ReferenceCountingGC objB = new ReferenceCountingGC();
  
          // 对象之间相互循环引用，对象objA和objB之间的引用计数永远不可能为 0
          objB.instance = objA;
          objA.instance = objB;
  
          objA = null;
          objB = null;
          
          //A对象和B对象已经不能访问，本该被回收掉，但是引用数不为0，无法被回收，
          //所以GC没有采用这样的机制
          System.gc();
      }
  }
  ```

- **可达性算法（根搜索算法）**

  以**GC Root**为根节点向下搜索，如果一个对象与Gc Root没有引用链相连，则是不可达的，可以回收。反之可达

  ![img](http://static.zybuluo.com/Rico123/q0t6nxkafapyn6yql7benc32/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

- **Gc Root** **有哪些？**

​      虚拟机栈(栈帧中的局部变量表)中引用的对象；

​      方法区中类静态属性引用的对象；

​      方法区中常量引用的对象；

​      本地方法栈中Native方法引用的对象；

大白话就是方法运行时，方法中引用的对象；类的静态变量引用的对象；类中常量引用的对象；Native方法中引用的对象和Thread。

- 现代虚拟机中的垃圾搜集算法：

  标记—清除算法

  复制算法

  标记—整理算法
  
  参考：<https://blog.csdn.net/plgy_Y/article/details/72791483>

​     关于内存泄漏的铺垫就到此为止了，下面几种常见的内存泄漏

### 3.常见的内存泄漏场景

#### static导致的内存泄漏

```java
public class StaticTestActivity extends AppCompatActivity{
    private static Context mContext;
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_static_test);
        mContext = this;
   
    }
}
```

静态变量引用的对象是GC root，mcontext又持有activity的引用，且静态变量的生命周期贯穿整个应用周期，导致即使activity退出后仍然不能被回收。产生内存泄漏

#### **handler**

```java
Handler handler = new Handler(){
    @Override
    public void handleMessage(Message msg) {
        super.handleMessage(msg);
        //处理msg
    }
};
protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_static_test);
        handler.sendMessageDelayed(new Message(),60000);//延时发送，模拟mesg被阻塞

    }
```

通过匿名内部类的方式创建handler，**hangdler会隐式持有activity**，msg被处理之前会一直存于消息队列中，msg持有handler，activity突然退出后不可被回收

解决途径：自定义静态handler类继承Handler，handler不再持有activity的强引用

#### **单例模式**

单例的静态特性使得其生命周期和应用的生命周期一样长（可参考上述static），如果一个对象已经不再需要使用了，而单例对象还持有该对象的引用，就会使得该对象不能被正常回收

#### Thread、Runnable、AsyncTask

和线程有关的类都**不要用匿名内部类来创建**，线程和活动的生命周期不同的，即便活动结束，在后台任务完成之前他们都会隐式持有activity的引用，导致activity不能回收

**集合**

集合类添加元素后，仍引用着集合元素对象，导致该集合中的元素对象无法被回收，从而导致内存泄露

```java
static List<Object> objectList = new ArrayList<>();
   for (int i = 0; i < 10; i++) {
       Object obj = new Object();
       objectList.add(obj);
       obj = null;
    }
```

使用完后将集合置空

```jav
bjectList.clear();
objectList = null;
```

#### 属性动画

无限循环的动画一定要在onDestory停止动画，动画会持有view，view持有activity，最终activity无法释放

#### **其他情况**

网络、文件等流忘记关闭

手动注册广播时，退出时忘记 unregisterReceiver()，被system强引用

Service 执行完后忘记 stopSelf()

EventBus 等观察者模式的框架忘记手动解除注册

### Android Lint

 **代码扫描分析工具**，它可以帮助我们发现代码结构/质量问题，同时提供一些解决方案

https://blog.csdn.net/u011240877/article/details/54141714

### 五、其他优化

关于drawable-mdpi，hdpi，xxhdpi下的区别

安卓加载图片的顺序：比如一个imageview设置了一张图片android:src="@drawable/android_logo"

当我们使用资源id来去引用一张图片时，首先从匹配手机dpi（现在一般是xxhdpi）的文件夹搜索，没有向上就搜索，直到最后也没找到就向下搜索直到找到（要是也没有最后去drawable-nodpi）

高dpi机器去引用低dpi图片，系统自动放大，占用多内存。反之减小

参考：<https://cloud.tencent.com/developer/article/1015960>