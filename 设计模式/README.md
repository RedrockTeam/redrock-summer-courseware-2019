

# 设计原则与设计模式

[TOC]

# 0. 前言

### 0.1 Java面向对象基础（*）

1. 继承、接口实现
2. 泛型（模版）

### 0.2 UML类图

1. 类的方法和属性

![image-20190814132434729](http://ww1.sinaimg.cn/large/006tNc79ly1g5z52qzoumj31bk0dithf.jpg)





2. 类与类之间的关系

   - 泛化与实现

     ![image-20190814132852285](http://ww3.sinaimg.cn/large/006tNc79ly1g5z576ax15j30wz0d6tb2.jpg)

     

   - 关联、依赖、组合、聚合

     ![image-20190814132951748](http://ww4.sinaimg.cn/large/006tNc79ly1g5z587nj30j310p0u0b16.jpg)



### 0.3 从面向对象到设计模式

- 模拟鸭子的问题（超类与子类）（P2*）

- 让鸭子能飞

- 橡皮鸭子也能飞？！（当涉及维护时，为了提高复用性而使用继承的效果并不好）

- 使用接口来解决？（复用性？）

- ==设计原则: 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起==

- ==设计原则:多用组合，少用继承==

- 将行为从Duck类中分离，建立一组新类来代表每个行为

- ==设计原则:针对接口（超类型）编程，而不是针对实现编程，在运行时才指定具体实现的对象==

- 动态设置行为






# 1. 行为型模式

### 1.1 策略模式

- 定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户

  

### 1.2 模版方法模式

- 模版方法代码：抽象超类定义程序骨架，子类实现具体步骤

- 模版：一个将算法定义成一组步骤方法的方法，其中任何步骤都可以时抽象的。由子类负责实现

- 钩子（Hook）方法：一种被声明在抽象类的方法，但有空的或默认的实现，创建框架或组件上的一种技巧，好让低层组件能够被挂钩进计算中

- Java API中的模版方法

- 模版方法模式vs策略模式

  

### 1.3 观察者模式

- 定义了对象之间的一对多依赖，这样当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新

- 气象管理站应用问题（代码）

- 主题不管观察者的具体实现，只知道它们都实现了Observer接口

- ==设计原则4:为交互对象间的松耦合而努力==，当两个对象之间送耦合，它们依然可以交互，但是不太清楚彼此的细节

- 观察者模式的一天（P46*）

- Java内置的观察者模式

  

### 1.4 状态模式

- 状态模式代码：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。从客户的视角看，状态机能在运行时改变自己的行为
- 状态模式vs策略模式





# 2. 创建型模式

### 2.1 单例模式

- 确保一个类只有一个实例，并提供一个全局访问点
- 多线程不同步问题

### 2.2 （伪）简单工厂模式

- 简单工厂代码：使用工厂类帮它的客户创建实例对象，将具体实例化从客户代码中删除

- 简单工厂不是模式

### 2.3 工厂方法模式

- 工厂方法模式代码：定义一个创建对象的“产品接口”，但是由之类决定要实例化的类（具体产品）是哪一个，工厂方法让类（抽象创建者）把实例化推迟到子类（具体创建者）
- 简单工厂/工厂方法模式（高层组件也在依赖低层的抽象）
- 依赖倒置（DIP）原则（依赖抽象，不依赖具体类）

### 2.4 抽象工厂模式

- 抽象工厂模式代码：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定类



# 3. 结构型模式

### 3.1 装饰者模式

- 连锁咖啡店问题
- 抽象超类继承？（牛奶价格上涨？新增一种焦糖风味）
- 认识装饰者模式
- ==设计原则：开放-关闭原则，允许类容易扩展，在不修改现有代码的前提下就可以搭配新的行为==
- Java API中的装饰者模式
- 动态将责任附加到对象上，若要扩展功能，装饰者比继承更有弹性

### 3.2 组合模式

- 组合模式代码：将对象组合成树型结构，能让客户以一致的方式处理个体以及组合
- 在多数情况下可以忽略对象组合和个体对象间的差别
- 一个遍历组合模式的迭代器
- GUI中的组合模式（透明性）

### 3.3 适配器模式 / 外观模式

- 将一个类的接口转换成客户期望的另一个接口（也可以让一个适配器包装多个被适配者）
- 适配器模式代码：火鸡变鸭子，可以响应客户代码
- 外观模式代码：提供一个统一的接口，用来访问子系统中的一群接口，使得子系统更容易使用。
- 设计原则：最小知识原则，不要让太多的类耦合在一起，免得修改一部分影响其他





# 4. 总结

### 4.1 混合模式（*）

### 4.2 设计模式病与设计原则

